{
    "schemes": [
        "http",
        "https"
    ],
    "swagger": "2.0",
    "info": {
        "title": "API for working with Horizon",
        "contact": {
            "name": "API support",
            "url": "https://github.com/LdDl/horizon#table-of-contents",
            "email": "sexykdi@gmail.com"
        },
        "version": "0.1.0"
    },
    "basePath": "/",
    "paths": {
        "/api/v0.1.0/isochrones": {
            "post": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Isochrones"
                ],
                "summary": "Find possible isochrones via POST-request",
                "parameters": [
                    {
                        "description": "Example of request",
                        "name": "POST-body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.IsochronesRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.IsochronesResponse"
                        }
                    },
                    "424": {
                        "description": "Failed Dependency",
                        "schema": {
                            "$ref": "#/definitions/codes.Error424"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/codes.Error500"
                        }
                    }
                }
            }
        },
        "/api/v0.1.0/mapmatch": {
            "post": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Map matching"
                ],
                "summary": "Do map match via POST-request",
                "parameters": [
                    {
                        "description": "Example of request",
                        "name": "POST-body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.MapMatchRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.MapMatchResponse"
                        }
                    },
                    "424": {
                        "description": "Failed Dependency",
                        "schema": {
                            "$ref": "#/definitions/codes.Error424"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/codes.Error500"
                        }
                    }
                }
            }
        },
        "/api/v0.1.0/shortest": {
            "post": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Routing"
                ],
                "summary": "Find shortest path via POST-request",
                "parameters": [
                    {
                        "description": "Example of request",
                        "name": "POST-body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.SPRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/rest.SPResponse"
                        }
                    },
                    "424": {
                        "description": "Failed Dependency",
                        "schema": {
                            "$ref": "#/definitions/codes.Error424"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/codes.Error500"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "codes.Error424": {
            "type": "object",
            "properties": {
                "Error": {
                    "description": "Error text",
                    "type": "string",
                    "example": "Failed Dependency"
                }
            }
        },
        "codes.Error500": {
            "type": "object",
            "properties": {
                "Error": {
                    "description": "Error text",
                    "type": "string",
                    "example": "Internal Server Error"
                }
            }
        },
        "horizon.MatcherCode": {
            "type": "integer",
            "enum": [
                900,
                901,
                902
            ],
            "x-enum-varnames": [
                "CODE_OK",
                "CODE_NO_CANDIDATES",
                "CODE_ALONE_OBSERVATION"
            ]
        },
        "rest.GPSToMapMatch": {
            "type": "object",
            "properties": {
                "accuracy": {
                    "description": "GPS measurement accuracy in meters (optional, \u003c=0 or null means use default sigma)",
                    "type": "number",
                    "example": 5
                },
                "lon_lat": {
                    "description": "[Longitude, Latitude]",
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "example": [
                        37.601249363208915,
                        55.745374309126895
                    ]
                },
                "tm": {
                    "description": "Timestamp. Field would be ignored for request on '/shortest' service.",
                    "type": "string",
                    "example": "2020-03-11T00:00:00"
                }
            }
        },
        "rest.GPSToShortestPath": {
            "type": "object",
            "properties": {
                "lon_lat": {
                    "description": "[Longitude, Latitude]",
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "example": [
                        37.601249363208915,
                        55.745374309126895
                    ]
                }
            }
        },
        "rest.IntermediateEdgeResponse": {
            "type": "object",
            "properties": {
                "geom": {
                    "description": "Edge geometry as GeoJSON LineString feature",
                    "type": "object"
                },
                "id": {
                    "description": "Edge identifier",
                    "type": "integer",
                    "example": 4278
                },
                "weight": {
                    "description": "Travel cost",
                    "type": "number"
                }
            }
        },
        "rest.IsochronesRequest": {
            "type": "object",
            "properties": {
                "lon_lat": {
                    "description": "[Longitude, Latitude]",
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "example": [
                        37.601249363208915,
                        55.745374309126895
                    ]
                },
                "max_cost": {
                    "description": "Max cost restrictions for single isochrone. Should be \u003e= 0.",
                    "type": "number",
                    "example": 2100
                },
                "nearest_radius": {
                    "description": "Max radius of search for nearest vertex.\nUse -1 for no limit, 0 for default (100m), or positive value.",
                    "type": "number",
                    "example": 100
                }
            }
        },
        "rest.IsochronesResponse": {
            "type": "object",
            "properties": {
                "warnings": {
                    "description": "Warnings",
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "Warning"
                    ]
                }
            }
        },
        "rest.MapMatchRequest": {
            "type": "object",
            "properties": {
                "gps": {
                    "description": "Set of GPS data",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest.GPSToMapMatch"
                    }
                },
                "max_states": {
                    "description": "Max number of states for single GPS point (in range [1, 10], default is 5). Field would be ignored for request on '/shortest' service.",
                    "type": "integer",
                    "example": 5
                },
                "state_radius": {
                    "description": "Max radius of search for potential candidates.\nUse -1 for no limit, 0 for default (50m), or positive value.",
                    "type": "number",
                    "example": 50
                }
            }
        },
        "rest.MapMatchResponse": {
            "type": "object",
            "properties": {
                "sub_matches": {
                    "description": "Array of sub-matches (segments split when route cannot be computed between consecutive points)",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest.SubMatchResponse"
                    }
                },
                "warnings": {
                    "description": "Warnings",
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "Warning"
                    ]
                }
            }
        },
        "rest.ObservationEdgeResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "description": "Matcher code providing additional info. 900 - OK, 901 - no candidates, 902 - orphan observation",
                    "allOf": [
                        {
                            "$ref": "#/definitions/horizon.MatcherCode"
                        }
                    ],
                    "example": 900
                },
                "edge_id": {
                    "description": "Matched edge identifier (0 if is_matched=false)",
                    "type": "integer",
                    "example": 3149
                },
                "is_matched": {
                    "description": "Whether this observation was successfully matched to a road (false if no candidates were found)",
                    "type": "boolean",
                    "example": true
                },
                "matched_edge": {
                    "description": "Corresponding matched edge as GeoJSON LineString feature (null if is_matched=false)",
                    "type": "object"
                },
                "matched_edge_cut": {
                    "description": "Cut for excess part of the matched edge. Will be null for every observation except the first and the last. Could be null for first/last edge when projection point corresponds to source/target vertices of the edge",
                    "type": "object"
                },
                "matched_vertex": {
                    "description": "Corresponding matched vertex as GeoJSON Point feature (null if is_matched=false)",
                    "type": "object"
                },
                "next_edges": {
                    "description": "Set of leading edges up to next observation (so these edges is not matched to any observation explicitly). Could be an empty array if observations are very close to each other or if it just last observation",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest.IntermediateEdgeResponse"
                    }
                },
                "obs_idx": {
                    "description": "Index of an observation. Index corresponds to index in incoming request",
                    "type": "integer",
                    "example": 0
                },
                "original_point": {
                    "description": "Original GPS point as GeoJSON Point feature (useful when is_matched=false)",
                    "type": "object"
                },
                "projected_point": {
                    "description": "Corresponding projection on the edge as GeoJSON Point feature (null if is_matched=false)",
                    "type": "object"
                },
                "vertex_id": {
                    "description": "Matched vertex identifier (0 if is_matched=false)",
                    "type": "integer",
                    "example": 44014
                }
            }
        },
        "rest.SPRequest": {
            "type": "object",
            "properties": {
                "gps": {
                    "description": "Set of GPS data",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest.GPSToShortestPath"
                    }
                },
                "state_radius": {
                    "description": "Max radius of search for potential candidates.\nUse -1 for no limit, 0 for default (100m), or positive value.",
                    "type": "number",
                    "example": 100
                }
            }
        },
        "rest.SPResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "description": "Set of matched edges for each path's edge as GeoJSON LineString objects. Each feature contains edge identifier (`id`), travel cost (`weight`) and geometry (`coordinates`)",
                    "type": "object"
                },
                "warnings": {
                    "description": "Warnings",
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "Warning"
                    ]
                }
            }
        },
        "rest.SubMatchResponse": {
            "type": "object",
            "properties": {
                "observations": {
                    "description": "Set of matched edges for observations in this segment",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest.ObservationEdgeResponse"
                    }
                },
                "probability": {
                    "description": "Probability from Viterbi algorithm for this segment",
                    "type": "number",
                    "example": -86.57852
                }
            }
        }
    }
}