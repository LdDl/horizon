// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.32.1
// source: map_match.proto

package protos_pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// User's request for map matching
type MapMatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Max number of states for single GPS point (in range [1, 10], default is 5). Field would be ignored for request on '/shortest' service.
	// Example: 5
	MaxStates *int32 `protobuf:"varint,1,opt,name=max_states,json=maxStates,proto3,oneof" json:"max_states,omitempty"`
	// Max radius of search for potential candidates (in range [7, 50], default is 25.0)
	// Example: 7.0
	StateRadius *float64 `protobuf:"fixed64,2,opt,name=state_radius,json=stateRadius,proto3,oneof" json:"state_radius,omitempty"`
	// Set of GPS data
	Gps           []*GPSToMapMatch `protobuf:"bytes,3,rep,name=gps,proto3" json:"gps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MapMatchRequest) Reset() {
	*x = MapMatchRequest{}
	mi := &file_map_match_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MapMatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapMatchRequest) ProtoMessage() {}

func (x *MapMatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapMatchRequest.ProtoReflect.Descriptor instead.
func (*MapMatchRequest) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{0}
}

func (x *MapMatchRequest) GetMaxStates() int32 {
	if x != nil && x.MaxStates != nil {
		return *x.MaxStates
	}
	return 0
}

func (x *MapMatchRequest) GetStateRadius() float64 {
	if x != nil && x.StateRadius != nil {
		return *x.StateRadius
	}
	return 0
}

func (x *MapMatchRequest) GetGps() []*GPSToMapMatch {
	if x != nil {
		return x.Gps
	}
	return nil
}

// Representation of GPS data
type GPSToMapMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamp. Field would be ignored for request on '/shortest' service.
	// Example: 2020-03-11T00:00:00
	Tm string `protobuf:"bytes,1,opt,name=tm,proto3" json:"tm,omitempty"`
	// Longitude
	// Example: 37.601249363208915
	Lon float64 `protobuf:"fixed64,3,opt,name=lon,proto3" json:"lon,omitempty"`
	// Latitude
	// Example: 55.745374309126895
	Lat float64 `protobuf:"fixed64,4,opt,name=lat,proto3" json:"lat,omitempty"`
	// GPS measurement accuracy in meters (optional, <=0 or null means use default sigma)
	// Example: 5.0
	Accuracy      *float64 `protobuf:"fixed64,5,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GPSToMapMatch) Reset() {
	*x = GPSToMapMatch{}
	mi := &file_map_match_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GPSToMapMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GPSToMapMatch) ProtoMessage() {}

func (x *GPSToMapMatch) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GPSToMapMatch.ProtoReflect.Descriptor instead.
func (*GPSToMapMatch) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{1}
}

func (x *GPSToMapMatch) GetTm() string {
	if x != nil {
		return x.Tm
	}
	return ""
}

func (x *GPSToMapMatch) GetLon() float64 {
	if x != nil {
		return x.Lon
	}
	return 0
}

func (x *GPSToMapMatch) GetLat() float64 {
	if x != nil {
		return x.Lat
	}
	return 0
}

func (x *GPSToMapMatch) GetAccuracy() float64 {
	if x != nil && x.Accuracy != nil {
		return *x.Accuracy
	}
	return 0
}

// A single continuous matched segment
type SubMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Set of matched edges for observations in this segment
	Observations []*ObservationEdge `protobuf:"bytes,1,rep,name=observations,proto3" json:"observations,omitempty"`
	// Probability from Viterbi algorithm for this segment
	// Example: -86.578520
	Probability   float64 `protobuf:"fixed64,2,opt,name=probability,proto3" json:"probability,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubMatch) Reset() {
	*x = SubMatch{}
	mi := &file_map_match_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubMatch) ProtoMessage() {}

func (x *SubMatch) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubMatch.ProtoReflect.Descriptor instead.
func (*SubMatch) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{2}
}

func (x *SubMatch) GetObservations() []*ObservationEdge {
	if x != nil {
		return x.Observations
	}
	return nil
}

func (x *SubMatch) GetProbability() float64 {
	if x != nil {
		return x.Probability
	}
	return 0
}

// Server's response for map matching request
type MapMatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Array of sub-matches (segments split when route cannot be computed between consecutive points)
	SubMatches []*SubMatch `protobuf:"bytes,1,rep,name=sub_matches,json=subMatches,proto3" json:"sub_matches,omitempty"`
	// List of warnings
	Warnings      []string `protobuf:"bytes,2,rep,name=warnings,proto3" json:"warnings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MapMatchResponse) Reset() {
	*x = MapMatchResponse{}
	mi := &file_map_match_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MapMatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapMatchResponse) ProtoMessage() {}

func (x *MapMatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapMatchResponse.ProtoReflect.Descriptor instead.
func (*MapMatchResponse) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{3}
}

func (x *MapMatchResponse) GetSubMatches() []*SubMatch {
	if x != nil {
		return x.SubMatches
	}
	return nil
}

func (x *MapMatchResponse) GetWarnings() []string {
	if x != nil {
		return x.Warnings
	}
	return nil
}

// Relation between observation and matched edge
type ObservationEdge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Index of an observation. Index correspondes to index in incoming request. If some indices are not presented then it means that they have been trimmed
	// Example: 0
	ObsIdx int32 `protobuf:"varint,1,opt,name=obs_idx,json=obsIdx,proto3" json:"obs_idx,omitempty"`
	// Matched edge identifier
	// Example: 3149
	EdgeId int64 `protobuf:"varint,2,opt,name=edge_id,json=edgeId,proto3" json:"edge_id,omitempty"`
	// Matched vertex identifier
	// Example: 44014
	VertexId int64 `protobuf:"varint,3,opt,name=vertex_id,json=vertexId,proto3" json:"vertex_id,omitempty"`
	// Corresponding matched edge as line feature
	MatchedEdge []*GeoPoint `protobuf:"bytes,4,rep,name=matched_edge,json=matchedEdge,proto3" json:"matched_edge,omitempty"`
	// Cut for excess part of the matched edge. Will be null for every observation except the first and the last. Could be null for first/last edge when projection point corresponds to source/target vertices of the edge
	MatchedEdgeCut []*GeoPoint `protobuf:"bytes,5,rep,name=matched_edge_cut,json=matchedEdgeCut,proto3" json:"matched_edge_cut,omitempty"`
	// Corresponding matched vertex as point feature
	MatchedVertex *GeoPoint `protobuf:"bytes,6,opt,name=matched_vertex,json=matchedVertex,proto3" json:"matched_vertex,omitempty"`
	// Corresponding projection on the edge as point feature
	ProjectedPoint *GeoPoint `protobuf:"bytes,7,opt,name=projected_point,json=projectedPoint,proto3" json:"projected_point,omitempty"`
	// Set of leading edges up to next observation (so these edges is not matched to any observation explicitly). Could be an empty array if observations are very close to each other or if it just last observation
	NextEdges     []*IntermediateEdge `protobuf:"bytes,8,rep,name=next_edges,json=nextEdges,proto3" json:"next_edges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ObservationEdge) Reset() {
	*x = ObservationEdge{}
	mi := &file_map_match_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ObservationEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObservationEdge) ProtoMessage() {}

func (x *ObservationEdge) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObservationEdge.ProtoReflect.Descriptor instead.
func (*ObservationEdge) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{4}
}

func (x *ObservationEdge) GetObsIdx() int32 {
	if x != nil {
		return x.ObsIdx
	}
	return 0
}

func (x *ObservationEdge) GetEdgeId() int64 {
	if x != nil {
		return x.EdgeId
	}
	return 0
}

func (x *ObservationEdge) GetVertexId() int64 {
	if x != nil {
		return x.VertexId
	}
	return 0
}

func (x *ObservationEdge) GetMatchedEdge() []*GeoPoint {
	if x != nil {
		return x.MatchedEdge
	}
	return nil
}

func (x *ObservationEdge) GetMatchedEdgeCut() []*GeoPoint {
	if x != nil {
		return x.MatchedEdgeCut
	}
	return nil
}

func (x *ObservationEdge) GetMatchedVertex() *GeoPoint {
	if x != nil {
		return x.MatchedVertex
	}
	return nil
}

func (x *ObservationEdge) GetProjectedPoint() *GeoPoint {
	if x != nil {
		return x.ProjectedPoint
	}
	return nil
}

func (x *ObservationEdge) GetNextEdges() []*IntermediateEdge {
	if x != nil {
		return x.NextEdges
	}
	return nil
}

// Edge which is not matched to any observation but helps to form whole travel path
type IntermediateEdge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Edge geometry as line feature
	Geom []*GeoPoint `protobuf:"bytes,1,rep,name=geom,proto3" json:"geom,omitempty"`
	// Travel cost
	// Example: 2.0
	Weight float64 `protobuf:"fixed64,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// Edge identifier
	// Example: 4278
	Id            int64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IntermediateEdge) Reset() {
	*x = IntermediateEdge{}
	mi := &file_map_match_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntermediateEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntermediateEdge) ProtoMessage() {}

func (x *IntermediateEdge) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntermediateEdge.ProtoReflect.Descriptor instead.
func (*IntermediateEdge) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{5}
}

func (x *IntermediateEdge) GetGeom() []*GeoPoint {
	if x != nil {
		return x.Geom
	}
	return nil
}

func (x *IntermediateEdge) GetWeight() float64 {
	if x != nil {
		return x.Weight
	}
	return 0
}

func (x *IntermediateEdge) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

var File_map_match_proto protoreflect.FileDescriptor

const file_map_match_proto_rawDesc = "" +
	"\n" +
	"\x0fmap_match.proto\x12\ahorizon\x1a\vpoint.proto\"\xa7\x01\n" +
	"\x0fMapMatchRequest\x12\"\n" +
	"\n" +
	"max_states\x18\x01 \x01(\x05H\x00R\tmaxStates\x88\x01\x01\x12&\n" +
	"\fstate_radius\x18\x02 \x01(\x01H\x01R\vstateRadius\x88\x01\x01\x12(\n" +
	"\x03gps\x18\x03 \x03(\v2\x16.horizon.GPSToMapMatchR\x03gpsB\r\n" +
	"\v_max_statesB\x0f\n" +
	"\r_state_radius\"q\n" +
	"\rGPSToMapMatch\x12\x0e\n" +
	"\x02tm\x18\x01 \x01(\tR\x02tm\x12\x10\n" +
	"\x03lon\x18\x03 \x01(\x01R\x03lon\x12\x10\n" +
	"\x03lat\x18\x04 \x01(\x01R\x03lat\x12\x1f\n" +
	"\baccuracy\x18\x05 \x01(\x01H\x00R\baccuracy\x88\x01\x01B\v\n" +
	"\t_accuracy\"j\n" +
	"\bSubMatch\x12<\n" +
	"\fobservations\x18\x01 \x03(\v2\x18.horizon.ObservationEdgeR\fobservations\x12 \n" +
	"\vprobability\x18\x02 \x01(\x01R\vprobability\"b\n" +
	"\x10MapMatchResponse\x122\n" +
	"\vsub_matches\x18\x01 \x03(\v2\x11.horizon.SubMatchR\n" +
	"subMatches\x12\x1a\n" +
	"\bwarnings\x18\x02 \x03(\tR\bwarnings\"\x83\x03\n" +
	"\x0fObservationEdge\x12\x17\n" +
	"\aobs_idx\x18\x01 \x01(\x05R\x06obsIdx\x12\x17\n" +
	"\aedge_id\x18\x02 \x01(\x03R\x06edgeId\x12\x1b\n" +
	"\tvertex_id\x18\x03 \x01(\x03R\bvertexId\x124\n" +
	"\fmatched_edge\x18\x04 \x03(\v2\x11.horizon.GeoPointR\vmatchedEdge\x12;\n" +
	"\x10matched_edge_cut\x18\x05 \x03(\v2\x11.horizon.GeoPointR\x0ematchedEdgeCut\x128\n" +
	"\x0ematched_vertex\x18\x06 \x01(\v2\x11.horizon.GeoPointR\rmatchedVertex\x12:\n" +
	"\x0fprojected_point\x18\a \x01(\v2\x11.horizon.GeoPointR\x0eprojectedPoint\x128\n" +
	"\n" +
	"next_edges\x18\b \x03(\v2\x19.horizon.IntermediateEdgeR\tnextEdges\"a\n" +
	"\x10IntermediateEdge\x12%\n" +
	"\x04geom\x18\x01 \x03(\v2\x11.horizon.GeoPointR\x04geom\x12\x16\n" +
	"\x06weight\x18\x02 \x01(\x01R\x06weight\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\x03R\x02idB\x0eZ\f./;protos_pbb\x06proto3"

var (
	file_map_match_proto_rawDescOnce sync.Once
	file_map_match_proto_rawDescData []byte
)

func file_map_match_proto_rawDescGZIP() []byte {
	file_map_match_proto_rawDescOnce.Do(func() {
		file_map_match_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_map_match_proto_rawDesc), len(file_map_match_proto_rawDesc)))
	})
	return file_map_match_proto_rawDescData
}

var file_map_match_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_map_match_proto_goTypes = []any{
	(*MapMatchRequest)(nil),  // 0: horizon.MapMatchRequest
	(*GPSToMapMatch)(nil),    // 1: horizon.GPSToMapMatch
	(*SubMatch)(nil),         // 2: horizon.SubMatch
	(*MapMatchResponse)(nil), // 3: horizon.MapMatchResponse
	(*ObservationEdge)(nil),  // 4: horizon.ObservationEdge
	(*IntermediateEdge)(nil), // 5: horizon.IntermediateEdge
	(*GeoPoint)(nil),         // 6: horizon.GeoPoint
}
var file_map_match_proto_depIdxs = []int32{
	1, // 0: horizon.MapMatchRequest.gps:type_name -> horizon.GPSToMapMatch
	4, // 1: horizon.SubMatch.observations:type_name -> horizon.ObservationEdge
	2, // 2: horizon.MapMatchResponse.sub_matches:type_name -> horizon.SubMatch
	6, // 3: horizon.ObservationEdge.matched_edge:type_name -> horizon.GeoPoint
	6, // 4: horizon.ObservationEdge.matched_edge_cut:type_name -> horizon.GeoPoint
	6, // 5: horizon.ObservationEdge.matched_vertex:type_name -> horizon.GeoPoint
	6, // 6: horizon.ObservationEdge.projected_point:type_name -> horizon.GeoPoint
	5, // 7: horizon.ObservationEdge.next_edges:type_name -> horizon.IntermediateEdge
	6, // 8: horizon.IntermediateEdge.geom:type_name -> horizon.GeoPoint
	9, // [9:9] is the sub-list for method output_type
	9, // [9:9] is the sub-list for method input_type
	9, // [9:9] is the sub-list for extension type_name
	9, // [9:9] is the sub-list for extension extendee
	0, // [0:9] is the sub-list for field type_name
}

func init() { file_map_match_proto_init() }
func file_map_match_proto_init() {
	if File_map_match_proto != nil {
		return
	}
	file_point_proto_init()
	file_map_match_proto_msgTypes[0].OneofWrappers = []any{}
	file_map_match_proto_msgTypes[1].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_map_match_proto_rawDesc), len(file_map_match_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_map_match_proto_goTypes,
		DependencyIndexes: file_map_match_proto_depIdxs,
		MessageInfos:      file_map_match_proto_msgTypes,
	}.Build()
	File_map_match_proto = out.File
	file_map_match_proto_goTypes = nil
	file_map_match_proto_depIdxs = nil
}
