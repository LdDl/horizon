// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.1
// 	protoc        v5.29.2
// source: map_match.proto

package protos_pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// User's request for map matching
type MapMatchRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Max number of states for single GPS point (in range [1, 10], default is 5). Field would be ignored for request on '/shortest' service.
	// Example: 5
	MaxStates *int32 `protobuf:"varint,1,opt,name=max_states,json=maxStates,proto3,oneof" json:"max_states,omitempty"`
	// Max radius of search for potential candidates (in range [7, 50], default is 25.0)
	// Example: 7.0
	StateRadius *float64 `protobuf:"fixed64,2,opt,name=state_radius,json=stateRadius,proto3,oneof" json:"state_radius,omitempty"`
	// Set of GPS data
	Gps []*GPSToMapMatch `protobuf:"bytes,3,rep,name=gps,proto3" json:"gps,omitempty"`
}

func (x *MapMatchRequest) Reset() {
	*x = MapMatchRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_map_match_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MapMatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapMatchRequest) ProtoMessage() {}

func (x *MapMatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapMatchRequest.ProtoReflect.Descriptor instead.
func (*MapMatchRequest) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{0}
}

func (x *MapMatchRequest) GetMaxStates() int32 {
	if x != nil && x.MaxStates != nil {
		return *x.MaxStates
	}
	return 0
}

func (x *MapMatchRequest) GetStateRadius() float64 {
	if x != nil && x.StateRadius != nil {
		return *x.StateRadius
	}
	return 0
}

func (x *MapMatchRequest) GetGps() []*GPSToMapMatch {
	if x != nil {
		return x.Gps
	}
	return nil
}

// Representation of GPS data
type GPSToMapMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Timestamp. Field would be ignored for request on '/shortest' service.
	// Example: 2020-03-11T00:00:00
	Tm string `protobuf:"bytes,1,opt,name=tm,proto3" json:"tm,omitempty"`
	// Longitude
	// Example: 37.601249363208915
	Lon float64 `protobuf:"fixed64,3,opt,name=lon,proto3" json:"lon,omitempty"`
	// Latitude
	// Example: 55.745374309126895
	Lat float64 `protobuf:"fixed64,4,opt,name=lat,proto3" json:"lat,omitempty"`
}

func (x *GPSToMapMatch) Reset() {
	*x = GPSToMapMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_map_match_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GPSToMapMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GPSToMapMatch) ProtoMessage() {}

func (x *GPSToMapMatch) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GPSToMapMatch.ProtoReflect.Descriptor instead.
func (*GPSToMapMatch) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{1}
}

func (x *GPSToMapMatch) GetTm() string {
	if x != nil {
		return x.Tm
	}
	return ""
}

func (x *GPSToMapMatch) GetLon() float64 {
	if x != nil {
		return x.Lon
	}
	return 0
}

func (x *GPSToMapMatch) GetLat() float64 {
	if x != nil {
		return x.Lat
	}
	return 0
}

// Server's response for map matching request
type MapMatchResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Set of matched edges for each observation
	Data []*ObservationEdge `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	// List of warnings
	Warnings []string `protobuf:"bytes,2,rep,name=warnings,proto3" json:"warnings,omitempty"`
}

func (x *MapMatchResponse) Reset() {
	*x = MapMatchResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_map_match_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MapMatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapMatchResponse) ProtoMessage() {}

func (x *MapMatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapMatchResponse.ProtoReflect.Descriptor instead.
func (*MapMatchResponse) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{2}
}

func (x *MapMatchResponse) GetData() []*ObservationEdge {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *MapMatchResponse) GetWarnings() []string {
	if x != nil {
		return x.Warnings
	}
	return nil
}

// Relation between observation and matched edge
type ObservationEdge struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Index of an observation. Index correspondes to index in incoming request. If some indices are not presented then it means that they have been trimmed
	// Example: 0
	ObsIdx int32 `protobuf:"varint,1,opt,name=obs_idx,json=obsIdx,proto3" json:"obs_idx,omitempty"`
	// Matched edge identifier
	// Example: 3149
	EdgeId int64 `protobuf:"varint,2,opt,name=edge_id,json=edgeId,proto3" json:"edge_id,omitempty"`
	// Matched vertex identifier
	// Example: 44014
	VertexId int64 `protobuf:"varint,3,opt,name=vertex_id,json=vertexId,proto3" json:"vertex_id,omitempty"`
	// Corresponding matched edge as line feature
	MatchedEdge []*GeoPoint `protobuf:"bytes,4,rep,name=matched_edge,json=matchedEdge,proto3" json:"matched_edge,omitempty"`
	// Cut for excess part of the matched edge. Will be null for every observation except the first and the last. Could be null for first/last edge when projection point corresponds to source/target vertices of the edge
	MatchedEdgeCut []*GeoPoint `protobuf:"bytes,5,rep,name=matched_edge_cut,json=matchedEdgeCut,proto3" json:"matched_edge_cut,omitempty"`
	// Corresponding matched vertex as point feature
	MatchedVertex *GeoPoint `protobuf:"bytes,6,opt,name=matched_vertex,json=matchedVertex,proto3" json:"matched_vertex,omitempty"`
	// Corresponding projection on the edge as point feature
	ProjectedPoint *GeoPoint `protobuf:"bytes,7,opt,name=projected_point,json=projectedPoint,proto3" json:"projected_point,omitempty"`
	// Set of leading edges up to next observation (so these edges is not matched to any observation explicitly). Could be an empty array if observations are very close to each other or if it just last observation
	NextEdges []*IntermediateEdge `protobuf:"bytes,8,rep,name=next_edges,json=nextEdges,proto3" json:"next_edges,omitempty"`
}

func (x *ObservationEdge) Reset() {
	*x = ObservationEdge{}
	if protoimpl.UnsafeEnabled {
		mi := &file_map_match_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ObservationEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObservationEdge) ProtoMessage() {}

func (x *ObservationEdge) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObservationEdge.ProtoReflect.Descriptor instead.
func (*ObservationEdge) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{3}
}

func (x *ObservationEdge) GetObsIdx() int32 {
	if x != nil {
		return x.ObsIdx
	}
	return 0
}

func (x *ObservationEdge) GetEdgeId() int64 {
	if x != nil {
		return x.EdgeId
	}
	return 0
}

func (x *ObservationEdge) GetVertexId() int64 {
	if x != nil {
		return x.VertexId
	}
	return 0
}

func (x *ObservationEdge) GetMatchedEdge() []*GeoPoint {
	if x != nil {
		return x.MatchedEdge
	}
	return nil
}

func (x *ObservationEdge) GetMatchedEdgeCut() []*GeoPoint {
	if x != nil {
		return x.MatchedEdgeCut
	}
	return nil
}

func (x *ObservationEdge) GetMatchedVertex() *GeoPoint {
	if x != nil {
		return x.MatchedVertex
	}
	return nil
}

func (x *ObservationEdge) GetProjectedPoint() *GeoPoint {
	if x != nil {
		return x.ProjectedPoint
	}
	return nil
}

func (x *ObservationEdge) GetNextEdges() []*IntermediateEdge {
	if x != nil {
		return x.NextEdges
	}
	return nil
}

// Edge which is not matched to any observation but helps to form whole travel path
type IntermediateEdge struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Edge geometry as line feature
	Geom []*GeoPoint `protobuf:"bytes,1,rep,name=geom,proto3" json:"geom,omitempty"`
	// Travel cost
	// Example: 2.0
	Weight float64 `protobuf:"fixed64,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// Edge identifier
	// Example: 4278
	Id int64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *IntermediateEdge) Reset() {
	*x = IntermediateEdge{}
	if protoimpl.UnsafeEnabled {
		mi := &file_map_match_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IntermediateEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntermediateEdge) ProtoMessage() {}

func (x *IntermediateEdge) ProtoReflect() protoreflect.Message {
	mi := &file_map_match_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntermediateEdge.ProtoReflect.Descriptor instead.
func (*IntermediateEdge) Descriptor() ([]byte, []int) {
	return file_map_match_proto_rawDescGZIP(), []int{4}
}

func (x *IntermediateEdge) GetGeom() []*GeoPoint {
	if x != nil {
		return x.Geom
	}
	return nil
}

func (x *IntermediateEdge) GetWeight() float64 {
	if x != nil {
		return x.Weight
	}
	return 0
}

func (x *IntermediateEdge) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

var File_map_match_proto protoreflect.FileDescriptor

var file_map_match_proto_rawDesc = []byte{
	0x0a, 0x0f, 0x6d, 0x61, 0x70, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x07, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x6f, 0x6e, 0x1a, 0x0b, 0x70, 0x6f, 0x69, 0x6e,
	0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa7, 0x01, 0x0a, 0x0f, 0x4d, 0x61, 0x70, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x22, 0x0a, 0x0a, 0x6d,
	0x61, 0x78, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x48,
	0x00, 0x52, 0x09, 0x6d, 0x61, 0x78, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x88, 0x01, 0x01, 0x12,
	0x26, 0x0a, 0x0c, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x72, 0x61, 0x64, 0x69, 0x75, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x01, 0x48, 0x01, 0x52, 0x0b, 0x73, 0x74, 0x61, 0x74, 0x65, 0x52, 0x61,
	0x64, 0x69, 0x75, 0x73, 0x88, 0x01, 0x01, 0x12, 0x28, 0x0a, 0x03, 0x67, 0x70, 0x73, 0x18, 0x03,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x6f, 0x6e, 0x2e, 0x47,
	0x50, 0x53, 0x54, 0x6f, 0x4d, 0x61, 0x70, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x03, 0x67, 0x70,
	0x73, 0x42, 0x0d, 0x0a, 0x0b, 0x5f, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73,
	0x42, 0x0f, 0x0a, 0x0d, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x72, 0x61, 0x64, 0x69, 0x75,
	0x73, 0x22, 0x43, 0x0a, 0x0d, 0x47, 0x50, 0x53, 0x54, 0x6f, 0x4d, 0x61, 0x70, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
	0x74, 0x6d, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x03, 0x6c, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x01, 0x52, 0x03, 0x6c, 0x61, 0x74, 0x22, 0x5c, 0x0a, 0x10, 0x4d, 0x61, 0x70, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x04, 0x64, 0x61,
	0x74, 0x61, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x68, 0x6f, 0x72, 0x69, 0x7a,
	0x6f, 0x6e, 0x2e, 0x4f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x64,
	0x67, 0x65, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x77, 0x61, 0x72, 0x6e,
	0x69, 0x6e, 0x67, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x77, 0x61, 0x72, 0x6e,
	0x69, 0x6e, 0x67, 0x73, 0x22, 0x83, 0x03, 0x0a, 0x0f, 0x4f, 0x62, 0x73, 0x65, 0x72, 0x76, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x45, 0x64, 0x67, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x6f, 0x62, 0x73, 0x5f,
	0x69, 0x64, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f, 0x62, 0x73, 0x49, 0x64,
	0x78, 0x12, 0x17, 0x0a, 0x07, 0x65, 0x64, 0x67, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x03, 0x52, 0x06, 0x65, 0x64, 0x67, 0x65, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x65,
	0x72, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x76,
	0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x0c, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x64, 0x5f, 0x65, 0x64, 0x67, 0x65, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e,
	0x68, 0x6f, 0x72, 0x69, 0x7a, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x6f, 0x50, 0x6f, 0x69, 0x6e, 0x74,
	0x52, 0x0b, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x45, 0x64, 0x67, 0x65, 0x12, 0x3b, 0x0a,
	0x10, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x5f, 0x65, 0x64, 0x67, 0x65, 0x5f, 0x63, 0x75,
	0x74, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x6f,
	0x6e, 0x2e, 0x47, 0x65, 0x6f, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x0e, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x64, 0x45, 0x64, 0x67, 0x65, 0x43, 0x75, 0x74, 0x12, 0x38, 0x0a, 0x0e, 0x6d, 0x61,
	0x74, 0x63, 0x68, 0x65, 0x64, 0x5f, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x11, 0x2e, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x6f,
	0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x0d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x56, 0x65,
	0x72, 0x74, 0x65, 0x78, 0x12, 0x3a, 0x0a, 0x0f, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x65,
	0x64, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e,
	0x68, 0x6f, 0x72, 0x69, 0x7a, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x6f, 0x50, 0x6f, 0x69, 0x6e, 0x74,
	0x52, 0x0e, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x69, 0x6e, 0x74,
	0x12, 0x38, 0x0a, 0x0a, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x65, 0x64, 0x67, 0x65, 0x73, 0x18, 0x08,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x6f, 0x6e, 0x2e, 0x49,
	0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x45, 0x64, 0x67, 0x65, 0x52,
	0x09, 0x6e, 0x65, 0x78, 0x74, 0x45, 0x64, 0x67, 0x65, 0x73, 0x22, 0x61, 0x0a, 0x10, 0x49, 0x6e,
	0x74, 0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x45, 0x64, 0x67, 0x65, 0x12, 0x25,
	0x0a, 0x04, 0x67, 0x65, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x68,
	0x6f, 0x72, 0x69, 0x7a, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x6f, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x52,
	0x04, 0x67, 0x65, 0x6f, 0x6d, 0x12, 0x16, 0x0a, 0x06, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x0e, 0x0a,
	0x02, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x42, 0x0e, 0x5a,
	0x0c, 0x2e, 0x2f, 0x3b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x5f, 0x70, 0x62, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_map_match_proto_rawDescOnce sync.Once
	file_map_match_proto_rawDescData = file_map_match_proto_rawDesc
)

func file_map_match_proto_rawDescGZIP() []byte {
	file_map_match_proto_rawDescOnce.Do(func() {
		file_map_match_proto_rawDescData = protoimpl.X.CompressGZIP(file_map_match_proto_rawDescData)
	})
	return file_map_match_proto_rawDescData
}

var file_map_match_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_map_match_proto_goTypes = []interface{}{
	(*MapMatchRequest)(nil),  // 0: horizon.MapMatchRequest
	(*GPSToMapMatch)(nil),    // 1: horizon.GPSToMapMatch
	(*MapMatchResponse)(nil), // 2: horizon.MapMatchResponse
	(*ObservationEdge)(nil),  // 3: horizon.ObservationEdge
	(*IntermediateEdge)(nil), // 4: horizon.IntermediateEdge
	(*GeoPoint)(nil),         // 5: horizon.GeoPoint
}
var file_map_match_proto_depIdxs = []int32{
	1, // 0: horizon.MapMatchRequest.gps:type_name -> horizon.GPSToMapMatch
	3, // 1: horizon.MapMatchResponse.data:type_name -> horizon.ObservationEdge
	5, // 2: horizon.ObservationEdge.matched_edge:type_name -> horizon.GeoPoint
	5, // 3: horizon.ObservationEdge.matched_edge_cut:type_name -> horizon.GeoPoint
	5, // 4: horizon.ObservationEdge.matched_vertex:type_name -> horizon.GeoPoint
	5, // 5: horizon.ObservationEdge.projected_point:type_name -> horizon.GeoPoint
	4, // 6: horizon.ObservationEdge.next_edges:type_name -> horizon.IntermediateEdge
	5, // 7: horizon.IntermediateEdge.geom:type_name -> horizon.GeoPoint
	8, // [8:8] is the sub-list for method output_type
	8, // [8:8] is the sub-list for method input_type
	8, // [8:8] is the sub-list for extension type_name
	8, // [8:8] is the sub-list for extension extendee
	0, // [0:8] is the sub-list for field type_name
}

func init() { file_map_match_proto_init() }
func file_map_match_proto_init() {
	if File_map_match_proto != nil {
		return
	}
	file_point_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_map_match_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MapMatchRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_map_match_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GPSToMapMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_map_match_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MapMatchResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_map_match_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ObservationEdge); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_map_match_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IntermediateEdge); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_map_match_proto_msgTypes[0].OneofWrappers = []interface{}{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_map_match_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_map_match_proto_goTypes,
		DependencyIndexes: file_map_match_proto_depIdxs,
		MessageInfos:      file_map_match_proto_msgTypes,
	}.Build()
	File_map_match_proto = out.File
	file_map_match_proto_rawDesc = nil
	file_map_match_proto_goTypes = nil
	file_map_match_proto_depIdxs = nil
}
