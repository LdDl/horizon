syntax = "proto3";
package horizon;
option go_package = "./;protos_pb";

import "point.proto";

// User's request for map matching
message MapMatchRequest {
    // Max number of states for single GPS point (in range [1, 10], default is 5). Field would be ignored for request on '/shortest' service.
    // Example: 5
    optional int32 max_states = 1;
    // Max radius of search for potential candidates (in meters).
    // Use -1 for no limit, 0 or omit for default (50m), or positive value.
    optional double state_radius = 2;
    // Set of GPS data
    repeated GPSToMapMatch gps = 3;
}

// Representation of GPS data
message GPSToMapMatch {
    // Timestamp. Field would be ignored for request on '/shortest' service.
    // Example: 2020-03-11T00:00:00
    string tm = 1;
    // Longitude
    // Example: 37.601249363208915
    double lon = 3;
    // Latitude
    // Example: 55.745374309126895
    double lat = 4;
    // GPS measurement accuracy in meters (optional, <=0 or null means use default sigma)
    // Example: 5.0
    optional double accuracy = 5;
}

// A single continuous matched segment
message SubMatch {
    // Set of matched edges for observations in this segment
    repeated ObservationEdge observations = 1;
    // Probability from Viterbi algorithm for this segment
    // Example: -86.578520
    double probability = 2;
}

// Server's response for map matching request
message MapMatchResponse {
    // Array of sub-matches (segments split when route cannot be computed between consecutive points)
    repeated SubMatch sub_matches = 1;
    // List of warnings
    repeated string warnings = 2;
}

// Relation between observation and matched edge
message ObservationEdge {
    // Index of an observation. Index correspondes to index in incoming request. If some indices are not presented then it means that they have been trimmed
    // Example: 0
    int32 obs_idx = 1;
    // Whether this observation was successfully matched to a road (false if no candidates were found)
    // Example: true
    bool is_matched = 2;
    // Matched edge identifier (0 if is_matched=false)
    // Example: 3149
    int64 edge_id = 3;
    // Matched vertex identifier (0 if is_matched=false)
    // Example: 44014
    int64 vertex_id = 4;
    // Corresponding matched edge as line feature (empty if is_matched=false)
    repeated GeoPoint matched_edge = 5;
    // Cut for excess part of the matched edge. Will be null for every observation except the first and the last. Could be null for first/last edge when projection point corresponds to source/target vertices of the edge
    repeated GeoPoint matched_edge_cut = 6;
    // Corresponding matched vertex as point feature (null if is_matched=false)
    GeoPoint matched_vertex = 7;
    // Corresponding projection on the edge as point feature (null if is_matched=false)
    GeoPoint projected_point = 8;
    // Original GPS point as point feature (useful when is_matched=false)
    GeoPoint original_point = 9;
    // Set of leading edges up to next observation (so these edges is not matched to any observation explicitly). Could be an empty array if observations are very close to each other or if it just last observation
    repeated IntermediateEdge next_edges = 10;
}

// Edge which is not matched to any observation but helps to form whole travel path
message IntermediateEdge {
    // Edge geometry as line feature
    repeated GeoPoint geom = 1;
    // Travel cost
    // Example: 2.0
    double weight = 2;
    // Edge identifier
    // Example: 4278
    int64 id = 3;
}